#!/usr/bin/env python# -*- coding: utf-8 -*-import syssys.path.append('../')from config import configsfrom model import modelimport webimport utilimport datetimeimport timeimport _threadimport refrom model.orm import *urls = (    'Login', 'Login',    'SelectExamQuestionById','SelectExamQuestionById',    'SaveExam','SaveExam',    'gettime','gettime',    'HandInExam','HandInExam',    'recover_exam','recover_exam',    'new_exam','new_exam',)'''创建考试后，学生考试信息表就已经建立'''# 练习模式重新抽题class new_exam:    def POST(self):        web.header("Access-Control-Allow-Origin", "*")        session = web.ctx.session        information_data = model.Information_model.query('SELECT * FROM information WHERE \                            student_st_id=%s and exam_ex_id=%s' % (session.student_id, session.ex_id))        information = model.Information_model(**information_data[0])        information.in_state = '1'        information.inscore = -1        exam = model.Exam_model.getByArgs(ex_id=session.ex_id)        delta = datetime.timedelta(minutes=exam[0].ex_duration)        now = datetime.datetime.now()        end_time = now + delta        information.in_endtime = end_time.strftime('%Y-%m-%d %H:%M:%S')        information.update()        db.delete('exam_question', where="information_in_id = $information_in_id", vars={'information_in_id': information.in_id, })        Extract.extract()        response = util.Response(status=util.Status.__success__,)        return util.objtojson(response)# 练习模式不抽题,继续做题class recover_exam:    def POST(self):        web.header("Access-Control-Allow-Origin", "*")        session = web.ctx.session        information_data = model.Information_model.query('SELECT * FROM information WHERE \                            student_st_id=%s and exam_ex_id=%s' % (session.student_id, session.ex_id))        information = model.Information_model(**information_data[0])        now = datetime.datetime.now()        exam = model.Exam_model.getByArgs(ex_id=session.ex_id)        delta = datetime.timedelta(minutes=exam[0].ex_duration)        end_time = now + delta        information.in_endtime = end_time.strftime('%Y-%m-%d %H:%M:%S')        information.in_state = '1'        information.update()        response = util.Response(status=util.Status.__success__,)        return util.objtojson(response)# 提取题目（用于重新抽题）class Extract:    @classmethod    def extract(cls):        session = web.ctx.session                   # 获取客户端信息        information = model.Information_model.query('select * from information where exam_ex_id=%s\             and student_st_id = %s'%(session.ex_id,session.student_id))                    # 根据考试id和学生id获取考试信息表信息        information = model.Information_model(**information[0])                             # 根据考试信息表信息实例化对象        lists = model.Strategy_term_model.getByArgs(strategy_sg_id=information['sg_id'])    # 获取策略表的策略项        # util.getFileRotatingLog().debug(lists)                                              # 将学生信息写入到log文件        # util.getFileRotatingLog().debug(information)        # util.getFileRotatingLog().debug(session.ex_id)        for strategy_term in lists:                                                         # 根据策略项抽题            if strategy_term.sm_type == 'choice':                                           # 抽取选择题                if strategy_term.sm_knowledge == 0:                                         # 根据策略项，随机获取sm_number道题目，0为全部知识点                    result = model.Question_model.query('select * from question where qt_id \                              in (select question_qt_id from questions_bank_has_question where \                               questions_bank_qb_id = %s) and qt_type = %s and \                               qt_diffculty between %s and %s order by rand() limit %s' % \                                                        (strategy_term.qb_id, "'" + 'choice' + "'",                                                         strategy_term.sm_difficulty_low + 5,                                                         strategy_term.sm_difficulty_high, strategy_term.sm_number))                    result = [model.Question_model(**item) for item in result]                else:                                                                       # 确定知识点                    result = model.Question_model.query('select * from question where qt_id \                              in (select question_qt_id from questions_bank_has_question where \                               questions_bank_qb_id = %s) and qt_type = %s and knowledge_kl_id \                               = %s and qt_diffculty between %s and %s order by rand() limit %s' % \                                                        (strategy_term.qb_id, "'" + 'choice' + "'",                                                         strategy_term.sm_knowledge,                                                         strategy_term.sm_difficulty_low + 5,                                                         strategy_term.sm_difficulty_high,                                                         strategy_term.sm_number))                    result = [model.Question_model(**item) for item in result]                for question in result:                    qb = model.Questions_bank_model()                    print(strategy_term.qb_id)                    qb = qb.getByArgs(qb_id=strategy_term.qb_id)                    print(qb)                    qt_id = question.qt_id                    # 添加exam_questions                    exam_question = model.Exam_question_model()             # 实例化试题表                    exam_question.eq_lang = qb[0]['qb_lang']                    exam_question.information_in_id = information['in_id']                    exam_question['qt_id'] = qt_id                    exam_question['eq_lang'] = question.qt_lang             # 为exam_question表每道题添加语言项                    exam_question.eq_qt_type = question.qt_type                    exam_question.eq_pre_score = strategy_term.sm_score                    exam_question.eq_answer = "答案"                    eq_id = exam_question.insertBackid()                    # 插入到数据库            if strategy_term.sm_type == 'judge':                if strategy_term.sm_knowledge == 0:                    result = model.Question_model.query('select * from question where qt_id \                              in (select question_qt_id from questions_bank_has_question where \                               questions_bank_qb_id = %s) and qt_type = %s and \                               qt_diffculty between %s and %s order by rand() limit %s' % \                                                        (strategy_term.qb_id, "'" + 'judge' + "'",                                                         strategy_term.sm_difficulty_low + 5,                                                         strategy_term.sm_difficulty_high, strategy_term.sm_number))                    result = [model.Question_model(**item) for item in result]                else:                    result = model.Question_model.query('select * from question where qt_id \                              in (select question_qt_id from questions_bank_has_question where \                               questions_bank_qb_id = %s) and qt_type = %s and knowledge_kl_id \                               = %s and qt_diffculty between %s and %s order by rand() limit %s' % \                                                        (strategy_term.qb_id, "'" + 'judge' + "'",                                                         strategy_term.sm_knowledge,                                                         strategy_term.sm_difficulty_low + 5,                                                         strategy_term.sm_difficulty_high,                                                         strategy_term.sm_number))                    result = [model.Question_model(**item) for item in result]                for question in result:                    # 添加exam_question                    exam_question = model.Exam_question_model()                    exam_question.information_in_id = information['in_id']                    exam_question.qt_id = question.qt_id                    exam_question.eq_qt_type = question.qt_type                    exam_question.eq_pre_score = strategy_term.sm_score                    exam_question['eq_lang'] = question.qt_lang  # 为exam_question表每道题添加语言项                    exam_question.eq_answer = "答案"                    eq_id = exam_question.insertBackid()            if strategy_term.sm_type == 'filla':                if strategy_term.sm_knowledge == 0:                    result = model.Question_model.query('select * from question where qt_id \                              in (select question_qt_id from questions_bank_has_question where \                               questions_bank_qb_id = %s) and qt_type = %s and \                               qt_diffculty between %s and %s order by rand() limit %s' % \                                                        (strategy_term.qb_id, "'" + 'filla' + "'",                                                         strategy_term.sm_difficulty_low + 5,                                                         strategy_term.sm_difficulty_high, strategy_term.sm_number))                    result = [model.Question_model(**item) for item in result]                else:                    result = model.Question_model.query('select * from question where qt_id \                              in (select question_qt_id from questions_bank_has_question where \                               questions_bank_qb_id = %s) and qt_type = %s and knowledge_kl_id \                               = %s and qt_diffculty between %s and %s order by rand() limit %s' % \                                                        (strategy_term.qb_id, "'" + 'filla' + "'",                                                         strategy_term.sm_knowledge,                                                         strategy_term.sm_difficulty_low + 5,                                                         strategy_term.sm_difficulty_high,                                                         strategy_term.sm_number))                    result = [model.Question_model(**item) for item in result]                for question in result:                    # 添加exam_question                    exam_question = model.Exam_question_model()                    exam_question.information_in_id = information['in_id']                    exam_question.qt_id = question.qt_id                    exam_question.eq_qt_type = question.qt_type                    exam_question.eq_pre_score = strategy_term.sm_score                    exam_question['eq_lang'] = question.qt_lang  # 为exam_question表每道题添加语言项                    exam_question.eq_answer = "答案"                    eq_id = exam_question.insertBackid()            if strategy_term.sm_type == 'fillb':                print("重新抽题")                if strategy_term.sm_knowledge == 0:                    result = model.Question_model.query('select * from question where qt_id \                              in (select question_qt_id from questions_bank_has_question where \                               questions_bank_qb_id = %s) and qt_type = %s and \                               qt_diffculty between %s and %s order by rand() limit %s' % \                                                        (strategy_term.qb_id, "'" + 'fillb' + "'",                                                         strategy_term.sm_difficulty_low + 5,                                                         strategy_term.sm_difficulty_high, strategy_term.sm_number))                    result = [model.Question_model(**item) for item in result]                else:                    result = model.Question_model.query('select * from question where qt_id \                              in (select question_qt_id from questions_bank_has_question where \                               questions_bank_qb_id = %s) and qt_type = %s and knowledge_kl_id \                               = %s and qt_diffculty between %s and %s order by rand() limit %s' % \                                                        (strategy_term.qb_id, "'" + 'fillb' + "'",                                                         strategy_term.sm_knowledge,                                                         strategy_term.sm_difficulty_low + 5,                                                         strategy_term.sm_difficulty_high,                                                         strategy_term.sm_number))                    result = [model.Question_model(**item) for item in result]                for question in result:                    fillb_data = model.Fillb_model.getByPK(question.qt_id)                    # 统计空数量                    count = fillb_data.fb_pre_coding.count("&&&")                    count_num = count = count / 2                    print("空格数：", count_num)                    eq_id_data = []                    while count > 0:                        count = count - 1                        # 添加exam_question                        exam_question = model.Exam_question_model()                        exam_question.information_in_id = information['in_id']                        exam_question.qt_id = question.qt_id                        exam_question.eq_qt_type = question.qt_type                        exam_question.eq_pre_score = round(float(strategy_term.sm_score)/count_num,2)                        # exam_question['eq_lang'] = question.qt_lang  # 为exam_question表每道题添加语言项                        exam_question.eq_answer = "答案"                        eq_id = exam_question.insertBackid()            if strategy_term.sm_type == 'coding':                if strategy_term.sm_knowledge == 0:                    result = model.Question_model.query('select * from question where qt_id \                              in (select question_qt_id from questions_bank_has_question where \                               questions_bank_qb_id = %s) and qt_type = %s and \                               qt_diffculty between %s and %s order by rand() limit %s' % \                                                        (strategy_term.qb_id, "'" + 'coding' + "'",                                                         strategy_term.sm_difficulty_low + 5,                                                         strategy_term.sm_difficulty_high, strategy_term.sm_number))                    result = [model.Question_model(**item) for item in result]                else:                    result = model.Question_model.query('select * from question where qt_id \                              in (select question_qt_id from questions_bank_has_question where \                               questions_bank_qb_id = %s) and qt_type = %s and knowledge_kl_id \                               = %s and qt_diffculty between %s and %s order by rand() limit %s' % \                                                        (strategy_term.qb_id, "'" + 'coding' + "'",                                                         strategy_term.sm_knowledge,                                                         strategy_term.sm_difficulty_low + 5,                                                         strategy_term.sm_difficulty_high,                                                         strategy_term.sm_number))                    result = [model.Question_model(**item) for item in result]                for question in result:                    # 添加exam_question                    exam_question = model.Exam_question_model()                    exam_question.information_in_id = information['in_id']                    exam_question.qt_id = question.qt_id                    exam_question.eq_qt_type = question.qt_type                    exam_question.eq_pre_score = strategy_term.sm_score                    exam_question['eq_lang'] = question.qt_lang  # 为exam_question表每道题添加语言项                    exam_question.eq_answer = "答案"                    eq_id = exam_question.insertBackid()        response = util.Response(status=util.Status.__success__, )        return util.objtojson(response)# 学生登录class Login:    def GET(self):        print("login")        return web.seeother('/static/exam/login.html',True)    def POST(self):        web.header("Access-Control-Allow-Origin", "*")        # 接收参数        params = web.input()        session = web.ctx.session        must_params = set({'ex_id', 'student_id', 'password', 'qt_diffculty_down'})        if util.paramsok(must_params, params) == 2:            if params.ex_id ==None:                response = util.Response(status=util.Status.__error__, message=u"请将浏览器的兼容模式改为高速模式！")                return util.objtojson(response)        information_data= model.Information_model.query('select * from information where exam_ex_id=%s\             and student_st_id = %s'%(params.ex_id,params.student_id))        # 学生登录        if information_data:            information = model.Information_model(**information_data[0])            # exam = model.Exam_model.getByArgs(ex_id=params.ex_id)            exam = model.Exam_model.getByPK(params.ex_id)            if params.password!=exam.ex_login_password :                response = util.Response(status=util.Status.__error__, message=u"密码错误")                return util.objtojson(response)            # 学生登陆考试成功            # 判断是不是练习模式，而且状态为2            if exam.ex_type == '0':             # 正式考试                if information.in_state == '2':     # 提交试卷                    information.in_state = '1'      # 学生的考试状态变为参与                    now = datetime.datetime.now()   # 获取当前时间                    delta = datetime.timedelta(minutes=exam.ex_duration)    # 获取考试时间                    end_time = now + delta          # 获取考试的结束时间                    information.in_endtime = end_time                    information.in_temp_ip = web.ctx.ip                    information.in_ip = web.ctx.ip                    information.update()            # 更新学生考试信息表            if information.in_state == '0':         # 登陆前学生未参与考试                information.in_temp_ip = web.ctx.ip  # 获取学生登陆端的ip                if information.update():             # 更新学生考试信息表的IP                    information.in_state = '1'       # 学生的考试状态变为已参与                    information.in_ip = web.ctx.ip   # 获取ip                    now = datetime.datetime.now()                    delta = datetime.timedelta(minutes=exam.ex_duration)                    end_time = now + delta           # 获取考试时间和结束时间                    information.in_endtime = end_time.strftime('%Y-%m-%d %H:%M:%S')                    information.update()                    # 存储session                    web.setcookie('system_mangement', '', 120)                    session.student_id = params.student_id                    session.ex_id = params.ex_id                    # 根据策略id获取策略项，根据策略项抽题                    lists = model.Strategy_term_model.getByArgs(strategy_sg_id=information['sg_id'])                    for strategy_term in lists:                        if strategy_term.sm_type == 'choice':                            if strategy_term.sm_knowledge==0:           # 抽取任意知识点的选择题                                result = model.Question_model.query('select * from question where qt_id \                                          in (select question_qt_id from questions_bank_has_question where \                                           questions_bank_qb_id = %s) and qt_type = %s and \                                           qt_diffculty between %s and %s order by rand() limit %s' % \                                           (strategy_term.qb_id, "'" + 'choice' + "'",strategy_term.sm_difficulty_low + 5,                                            strategy_term.sm_difficulty_high,strategy_term.sm_number))                                result = [model.Question_model(**item) for item in result]                            else:                                       # 抽取相对应知识点的题                                result = model.Question_model.query('select * from question where qt_id \                                          in (select question_qt_id from questions_bank_has_question where \                                           questions_bank_qb_id = %s) and qt_type = %s and knowledge_kl_id \                                           = %s and qt_diffculty between %s and %s order by rand() limit %s' % \                                                                    (strategy_term.qb_id, "'" + 'choice' + "'",                                                                     strategy_term.sm_knowledge,                                                                     strategy_term.sm_difficulty_low +5,                                                                     strategy_term.sm_difficulty_high,                                                                     strategy_term.sm_number))                                result = [model.Question_model(**item) for item in result]                            for question in result:                                qt_id = question.qt_id                                # 添加exam_questions                                exam_question = model.Exam_question_model()                                exam_question.information_in_id = information['in_id']                                exam_question['qt_id'] = qt_id                                exam_question.eq_qt_type = question.qt_type                                exam_question.eq_pre_score = strategy_term.sm_score                                exam_question['eq_lang'] = question.qt_lang  # 为exam_question表每道题添加语言项                                exam_question.eq_answer = "答案"                                eq_id = exam_question.insertBackid()                        if strategy_term.sm_type == 'judge':                            if strategy_term.sm_knowledge==0:                                result = model.Question_model.query('select * from question where qt_id \                                          in (select question_qt_id from questions_bank_has_question where \                                           questions_bank_qb_id = %s) and qt_type = %s and \                                           qt_diffculty between %s and %s order by rand() limit %s' % \                                           (strategy_term.qb_id, "'" + 'judge' + "'",strategy_term.sm_difficulty_low + 5,                                            strategy_term.sm_difficulty_high,strategy_term.sm_number))                                result = [model.Question_model(**item) for item in result]                            else:                                result = model.Question_model.query('select * from question where qt_id \                                          in (select question_qt_id from questions_bank_has_question where \                                           questions_bank_qb_id = %s) and qt_type = %s and knowledge_kl_id \                                           = %s and qt_diffculty between %s and %s order by rand() limit %s' % \                                                                    (strategy_term.qb_id, "'" + 'judge' + "'",                                                                     strategy_term.sm_knowledge,                                                                     strategy_term.sm_difficulty_low+5,                                                                     strategy_term.sm_difficulty_high,                                                                     strategy_term.sm_number))                                result = [model.Question_model(**item) for item in result]                            for question in result:                                # 添加exam_question                                exam_question = model.Exam_question_model()                                exam_question.information_in_id = information['in_id']                                exam_question.qt_id = question.qt_id                                exam_question.eq_qt_type = question.qt_type                                exam_question.eq_pre_score = strategy_term.sm_score                                exam_question['eq_lang'] = question.qt_lang  # 为exam_question表每道题添加语言项                                exam_question.eq_answer = "答案"                                eq_id = exam_question.insertBackid()                        if strategy_term.sm_type == 'filla':                            if strategy_term.sm_knowledge==0:                                result = model.Question_model.query('select * from question where qt_id \                                          in (select question_qt_id from questions_bank_has_question where \                                           questions_bank_qb_id = %s) and qt_type = %s and \                                           qt_diffculty between %s and %s order by rand() limit %s' % \                                           (strategy_term.qb_id, "'" + 'filla' + "'",strategy_term.sm_difficulty_low + 5,                                            strategy_term.sm_difficulty_high,strategy_term.sm_number))                                result = [model.Question_model(**item) for item in result]                            else:                                result = model.Question_model.query('select * from question where qt_id \                                          in (select question_qt_id from questions_bank_has_question where \                                           questions_bank_qb_id = %s) and qt_type = %s and knowledge_kl_id \                                           = %s and qt_diffculty between %s and %s order by rand() limit %s' % \                                                                    (strategy_term.qb_id, "'" + 'filla' + "'",                                                                     strategy_term.sm_knowledge,                                                                     strategy_term.sm_difficulty_low+5,                                                                     strategy_term.sm_difficulty_high,                                                                     strategy_term.sm_number))                                result = [model.Question_model(**item) for item in result]                            for question in result:                                # 添加exam_question                                exam_question = model.Exam_question_model()                                exam_question.information_in_id = information['in_id']                                exam_question.qt_id = question.qt_id                                exam_question.eq_qt_type = question.qt_type                                exam_question.eq_pre_score = strategy_term.sm_score                                exam_question['eq_lang'] = question.qt_lang  # 为exam_question表每道题添加语言项                                exam_question.eq_answer = "答案"                                eq_id = exam_question.insertBackid()                        if strategy_term.sm_type == 'fillb':                            print("正在抽取程序填空题")                            if strategy_term.sm_knowledge==0:                                result = model.Question_model.query('select * from question where qt_id \                                          in (select question_qt_id from questions_bank_has_question where \                                           questions_bank_qb_id = %s) and qt_type = %s and \                                           qt_diffculty between %s and %s order by rand() limit %s' % \                                           (strategy_term.qb_id, "'" + 'fillb' + "'",strategy_term.sm_difficulty_low + 5,                                            strategy_term.sm_difficulty_high,strategy_term.sm_number))                                result = [model.Question_model(**item) for item in result]                                print("数据库中查询到的程序填空题信息：", util.objtojson(result))                            else:                                result = model.Question_model.query('select * from question where qt_id \                                          in (select question_qt_id from questions_bank_has_question where \                                           questions_bank_qb_id = %s) and qt_type = %s and knowledge_kl_id \                                           = %s and qt_diffculty between %s and %s order by rand() limit %s' % \                                                                    (strategy_term.qb_id, "'" + 'fillb' + "'",                                                                     strategy_term.sm_knowledge,                                                                     strategy_term.sm_difficulty_low+5,                                                                     strategy_term.sm_difficulty_high,                                                                     strategy_term.sm_number))                                result = [model.Question_model(**item) for item in result]                            for question in result:                                fillb_data = model.Fillb_model.getByPK(question.qt_id)                                # 统计空数量                                # ‘&&&’表示需要填充的空，一个空的格式为：&&&空&&&                                # 每个空都有一条exam_question记录                                count_num =count = fillb_data.fb_pre_coding.count("&&&")/ 2                                print("空格数量：", count_num)                                eq_id_data = []                                while count > 0:                                    count = count - 1                                    # 添加exam_question                                    exam_question = model.Exam_question_model()                                    exam_question.information_in_id = information['in_id']                                    exam_question.qt_id = question.qt_id                                    exam_question.eq_qt_type = question.qt_type                                    exam_question.eq_pre_score = round(float(strategy_term.sm_score)/count_num,2)                                    # exam_question['eq_lang'] = question.qt_lang  # 为exam_question表每道题添加语言项                                    exam_question.eq_answer = "答案"                                    eq_id = exam_question.insertBackid()                        if strategy_term.sm_type == 'coding':                            if strategy_term.sm_knowledge==0:                                result = model.Question_model.query('select * from question where qt_id \                                          in (select question_qt_id from questions_bank_has_question where \                                           questions_bank_qb_id = %s) and qt_type = %s and \                                           qt_diffculty between %s and %s order by rand() limit %s' % \                                           (strategy_term.qb_id, "'" + 'coding' + "'",strategy_term.sm_difficulty_low + 5,                                            strategy_term.sm_difficulty_high,strategy_term.sm_number))                                result = [model.Question_model(**item) for item in result]                            else:                                result = model.Question_model.query('select * from question where qt_id \                                          in (select question_qt_id from questions_bank_has_question where \                                           questions_bank_qb_id = %s) and qt_type = %s and knowledge_kl_id \                                           = %s and qt_diffculty between %s and %s order by rand() limit %s' % \                                                                    (strategy_term.qb_id, "'" + 'coding' + "'",                                                                     strategy_term.sm_knowledge,                                                                     strategy_term.sm_difficulty_low+5,                                                                     strategy_term.sm_difficulty_high,                                                                     strategy_term.sm_number))                                result = [model.Question_model(**item) for item in result]                            for question in result:                                # 添加exam_question                                exam_question = model.Exam_question_model()                                exam_question.information_in_id = information['in_id']                                exam_question.qt_id = question.qt_id                                exam_question.eq_qt_type = question.qt_type                                exam_question.eq_pre_score = strategy_term.sm_score                                exam_question['eq_lang'] = question.qt_lang  # 为exam_question表每道题添加语言项                                exam_question.eq_answer = "答案"                                eq_id = exam_question.insertBackid()                    response = util.Response(status=util.Status.__success__,)                    return util.objtojson(response)                else:                    print("ip_error")                # 如果ip重复，无法写入到数据库，写入失败，返回提示信息                    response = util.Response(status=util.Status.__error__, message=u"ip重复")                    return util.objtojson(response)            # 登陆前学生已经参与了考试，但是中途意外停止或者被教师端中断            elif information.in_state == '1':                session.student_id = params.student_id      # params为学生输入的登入信息                session.ex_id = params.ex_id                if datetime.datetime.now() >information.in_endtime:         # 查看学生考试信息表的时间                    response = util.Response(status=util.Status.__error__,message=u"考试已结束" )                    return util.objtojson(response)                if information.in_ip ==None:                                # 如果ip被清空，则重新获取ip                    information.in_ip = web.ctx.ip                    information.update()                if information.in_ip != web.ctx.ip:                    print("ip 不统一")                    response = util.Response(status=util.Status.__error__, message=u"必须使用同一台电脑登录")                    return util.objtojson(response)                response = util.Response(status=util.Status.__success__,)                return util.objtojson(response)            else:                response = util.Response(status=util.Status.__error__, message=u"已结束考试")                print("error")                return util.objtojson(response)        else:            response = util.Response(status=util.Status.__error__, message=u"您不在该场考试")            return util.objtojson(response)# 提交试卷class HandInExam:    def POST(self):        web.header("Access-Control-Allow-Origin", "*")        information = model.Information_model()        session = web.ctx.session        information_data = information.query('SELECT * FROM information WHERE \                    student_st_id=%s and exam_ex_id=%s' % (session.student_id, session.ex_id))        information = model.Information_model(**information_data[0])        information.in_endtime = datetime.datetime.now()        information.in_state = '2'        information.in_temp_ip = None        exam = model.Exam_model.getByPK(session.ex_id)        if exam.ex_type=="0":                               # 考试的模式，0为正式考试            # util.SaveFillb(information.in_id)            db.update('exam_question', where="information_in_id = %s" % (information.in_id), eq_get_score='-2', )            # information.in_score = util.upInformationScore(1000,information.in_id)            # while 1:            #     exam_question = model.Exam_question_model.getByArgs(information_in_id=information.in_id)            #     information.in_score = 0            #     flag = 0            #     for question in exam_question:            #         if question.eq_get_score >= 0:            #             information.in_score += question.eq_get_score            #         else:            #             flag = 1            #             break            #     if flag == 0:            #         break            #            # information.in_state = '2'            information.update()            response = util.Response(status=util.Status.__params_ok__,message=information.in_score )            return util.objtojson(response)        else:            if exam.ex_auto =="1":                          # 考试的模式，1为练习模式                # util.SaveFillb(information.in_id)                db.update('exam_question', where="information_in_id = %s" % (information.in_id), eq_get_score='-2', )                _thread.start_new(util.GetScore, (1,information.in_id))            information.update()            response = util.Response(status=util.Status.__success__, )            return util.objtojson(response)## class gettime:#     def POST(self):#         web.header("Access-Control-Allow-Origin", "*")#         information = model.Information_model()#         information_data = information.query('SELECT * FROM information WHERE \#                     student_st_id=2014112200 and exam_ex_id=1')#         information = model.Information_model(**information_data[0])#         db.update('exam_question', where="information_in_id = %s"%(information.in_id), eq_get_score='-2', )#         response = util.Response(status=util.Status.__success__,)#         return util.objtojson(response)# 导出考卷信息class SelectExamQuestionById:    def GET(self):        session = web.ctx.session        # print session.student_id        print('session.student_id ' + session.student_id)        return web.seeother('/static/exam/index.html',True)    def POST(self):        web.header("Access-Control-Allow-Origin", "*")        params = web.input()        information = model.Information_model()        session = web.ctx.session        if session.ex_id==None:            response = util.Response(status=util.Status.__error__)            return util.objtojson(response)        information_data = information.query('SELECT * FROM information WHERE \            student_st_id=%s and exam_ex_id=%s' % (session.student_id, session.ex_id))        information = model.Information_model(**information_data[0])        information.in_score = util.upInformationScore(information.in_id)        information.in_ip = information.in_temp_ip        # now = datetime.datetime.now()        # exam = model.Exam_model.getByPK(session.ex_id)        # delta = datetime.timedelta(minutes=exam.ex_duration)        # end_time = now + delta        # information.in_endtime = end_time.strftime('%Y-%m-%d %H:%M:%S')        information.update()        exam_question = model.Exam_question_model.getByArgs(information_in_id=information.in_id)        # util.getFileRotatingLog().debug(exam_question)        choice_question = []        judge_question = []        # filla是读程序写结果        filla_question = []        fillb_question = []        coding_question = []        for item in exam_question:            if item.eq_get_score < 0:                item.eq_get_score = u'未出分'            if item.eq_qt_type == 'choice':                question_data = model.Question_model.getByPK(item.qt_id)                choice_data = model.Choice_model.getByPK(item.qt_id)                item = dict(item, **choice_data)                item = dict(item, **question_data)                choice_question.append(item)            elif item.eq_qt_type == 'judge':                question_data = model.Question_model.getByPK(item.qt_id)                judge_data = model.Judge_model.getByPK(item.qt_id)                item = dict(item, **judge_data)                item = dict(item, **question_data)                judge_question.append(item)            elif item.eq_qt_type == 'filla':                question_data = model.Question_model.getByPK(item.qt_id)                filla_data = model.Filla_model.getByPK(item.qt_id)                item = dict(item, **filla_data)                item = dict(item, **question_data)                filla_question.append(item)            elif item.eq_qt_type == 'coding':                question_data = model.Question_model.getByPK(item.qt_id)                coding_data = model.Coding_model.getByPK(item.qt_id)                item = dict(item, **coding_data)                item = dict(item, **question_data)                coding_question.append(item)        fillb_qt = model.Exam_question_model.query('select distinct(qt_id),\                                                eq_pre_score from exam_question where information_in_id = %s \                                                and eq_qt_type = %s' % (information.in_id, "'" + 'fillb' + "'"))        for item in fillb_qt:            question_data = model.Question_model.getByPK(item['qt_id'])            fillb_data = model.Fillb_model.getByPK(item['qt_id'])            eq_id_data = model.Exam_question_model.query('select eq_id,eq_answer,eq_get_score from \                                                    exam_question where qt_id = %s and information_in_id = %s' \                                                         % (item['qt_id'], information.in_id))            eq_id_data = [model.Exam_question_model(**items) for items in eq_id_data]            for question in eq_id_data:                if question.eq_get_score <0:                    question.eq_get_score = u'未出分'            item = dict(item, **fillb_data)            item = dict(item, **question_data)            fillb = []            fillb.append(item)            fillb.append(eq_id_data)            fillb_question.append(fillb)        question_list = []        question_list.append(choice_question)        question_list.append(judge_question)        question_list.append(filla_question)        question_list.append(fillb_question)        question_list.append(coding_question)        student = model.Student_model.getByPK(session.student_id)        exam = model.Exam_model.getByPK(session.ex_id)        student['exam_name'] = exam.ex_name        if information['in_score'] == -1:            student['in_score'] = u'未出分,请稍后刷新该页面'        else:            student['in_score'] = information['in_score']        question_list.append(student)        time = information.in_endtime - datetime.datetime.now()        count = time.seconds*1000        response = util.Response(status=util.Status.__success__, body=question_list,message=count)        print(util.objtojson(response))        return util.objtojson(response)# 保存考卷class SaveExam:    def POST(self):        web.header("Access-Control-Allow-Origin", "*")        params = web.input()        session = web.ctx.session        exam_question = model.Exam_question_model(**params)        exam_information = model.Information_model.query('select * from information\         where student_st_id = %s and exam_ex_id = %s'%(session.student_id, session.ex_id))        information = exam_information[0]        exam = model.Exam_model.getByPK(session.ex_id)        # util.getFileRotatingLog().debug(session.ex_id)        # util.getFileRotatingLog().debug(exam)        if information.in_state !='1' or exam.ex_state != '1':            print("已结束考试")            util.getFileRotatingLog().debug(exam)            response = util.Response(status=util.Status.__error__, message="已结束考试")            return util.objtojson(response)        if exam_question.eq_qt_type == 'fillb':            # 从数据库中获取in_id,qt_id，得到有几个空            qt_id_and_in_id = model.Exam_question_model.getByPK(exam_question.eq_id)            # util.getFileRotatingLog().debug(qt_id_and_in_id)            question_num = model.Exam_question_model.query('select * from exam_question where qt_id \                           = %s and information_in_id = %s'%(qt_id_and_in_id.qt_id,qt_id_and_in_id.information_in_id))            question_num = [model.Exam_question_model(**item) for item in question_num]            # 获取fillb初始代码            fillb_question = model.Fillb_model.getByPK(qt_id_and_in_id.qt_id)            coding = fillb_question.fb_pre_coding            count = 0            for item in question_num:                count += 1                if qt_id_and_in_id.eq_id == item.eq_id:                    coding = re.sub(r'&&&([\s\S]*?)&&&',params.eq_answer,coding,1)                    util.getFileRotatingLog().debug(coding)                    util.getFileRotatingLog().debug(params.eq_answer)                else:                    # util.getFileRotatingLog().debug(count)                    coding = coding.replace("&&&", " ", 2)            exam_question.fillb_coding = coding        if exam_question.update():            time = information.in_endtime - datetime.datetime.now()            count = time.seconds * 1000            response = util.Response(status=util.Status.__success__,message=count)            return util.objtojson(response)        else:            response = util.Response(status=util.Status.__error__, )            return util.objtojson(response)app = web.application(urls, globals())render = web.template.render('template')if __name__ == '__main__':    if len(urls) & 1 == 1:        print("urls error, the size of urls must be even.")    else:        app.run()